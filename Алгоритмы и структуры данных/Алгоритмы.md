# Алгоритмы #

## Бинарный поиск.

Сложность Log<sub>2</sub>N

Условие применения: Поиск в отсортированном массиве

Суть: каждый раз берем средний элемент и сравниваем с искомым, если он больше,
делаем средний элемент нижним, если меньше верхним и повторяем

Код:

    public static int FindIndexOfNumber(int desiredNumber, int[] arr)
    {
        var firstIndex = 0;
        var lastIndex = arr.Length - 1;

        while (firstIndex <= lastIndex)
        {
            var midIndex = (lastIndex + firstIndex) / 2;
            var guess = arr[midIndex];

            if (guess == desiredNumber) return midIndex;

            if (guess < desiredNumber)
                firstIndex = midIndex + 1;
            else
                lastIndex = midIndex - 1;
        }

        return -1;
    }


## Сортировка выбором


Сложность: O(n<sup>2</sup>)

Суть: Находим самый большой/маленький элемент и меняем его с нулевым элементом, повторяем начиная со следующего элемента, пока не останется последний символ

Код:

    public static void Sort(int[] arr)
    {
        for (var i = 0; i < arr.Length - 1; i++)
        {
            var indexOfSmallestValue = GetIndexOfSmallestValue(arr, i);
            (arr[i], arr[indexOfSmallestValue]) = (arr[indexOfSmallestValue], arr[i]);
        }
    }

    private static int GetIndexOfSmallestValue(int[] arr, int firstIndex)
    {
        var indexOfSmallestValue = firstIndex;

        for (var i = firstIndex + 1; i < arr.Length; i++)
            if (arr[i] < arr[indexOfSmallestValue])
                indexOfSmallestValue = i;

        return indexOfSmallestValue;
    }
